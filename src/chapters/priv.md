---
title: Private Key Cryptography
name: priv
---

# Background Knowledge

In this assignment, you will build a secure communication platform. On startup, each client specifies whether it will *listen* or *connect* to another client; once two clients have connected, they will run a **key exchange protocol** to reach a shared secret. Once we have a shared secret, both parties run a **key derivation function** on it to derive a secure key for a **block cipher**, which they can then use to encrypt and decrypt messages in tandem. To ensure that messages aren't tampered with, each message is also tagged with a **message authentication code**, which are generated from another secure key. We go over each of these components in detail below.

## Key Exchange

We've already explored **key exchange** in the previous assignment, but it's worth revisiting. Often, when two parties wish to communicate securely, it is useful to have some shared secret key that they can use to encrypt and decrypt their messages. Indeed, the block cipher that we use in this assignment requires such a secret key. **Diffie-Hellman key exchange** is one method for coming to a shared secret key.

Diffie-Hellman works in three steps. First, system parameters are generated and shared amongst the parties. These parameters include a group $\mathbb{G}$ (e.g., $\mathbb{Z}_p^*$), a generator $g \in \mathbb{G}$, and the order $q$ of the group generated by $g$. Once these parameters are shared, the two parties randomly sample secrets $a, b \in \mathbb{Z}_q^*$ respectively, and share the public values $g^a, g^b \in \mathbb{Z}_p^*$ with each other. Finally, the secret and public values are combined to create a shared secret $g^{ab} \in \mathbb{Z}_p^*$.

## Block Ciphers

Often, we wish to encrypt large amounts of data without having to generate new secret keys each time nor comprimising the security of our existing key. A **block cipher** is an encryption scheme that works on fixed-length **blocks** at a time. They are very useful for encrypting large or arbitrary-length data, such as messages or videos. **AES (Advanced Encryption Standard)** is one such block cipher. It was adopted by NIST in 2001 after winning a 5-year public competition to become the new standard secure block cipher. To use AES, simply provide it with a message and a suitable key; it will then output the ciphertext (the API for AES is quite simple despite its complexity). The inner workings of AES are extremely complicated and out of scope for this class.

[There are many modes in which a block cipher can operate](https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation), but the one we'll be using is known as **cipher-block chaining mode**, or **CBC mode**. One nuance of this mode is that it requires each encryption to be initialized with an **initialization vector**, or IV for short, and each decryption should use the same IV when decrypting. The IV does not need to be kept secret, but it should be chosen at random.

## Message Integrity

An important aspect of communication is message integrity; we want to be sure that our messages haven't been tampered with in transit. A **MAC (Message Authentication Code)** is one way of cryptographically ensuring message integrity. A MAC generator takes in a shared secret and a message and outputs a tag for the message. A MAC verifier takes in the shared secret, a message, a MAC tag, and outputs "Verified" (or some other positive value) if and only if the MAC is valid for the given message. Otherwise, it rejects the tag, indicating that the value has been tampered with or that the MAC was generated incorrectly. It must be difficult for those without the shared secret to generate valid MACs for any message (otherwise, this wouldn't be secure). The MAC that is computed on some value can be thought of as a signature but with symmetric keys. In this assignment we use **HMAC (Hashed Message Authentication Code)**, a widely used MAC algorithm, to tag our messages.

We need to be careful about the order in which we apply our cryptographic primitives. In particular, do we compute MACs on the plaintext and then encrypt the message along with the tag, or do we encrypt our plaintext first and then compute MAC on the resulting ciphertext? It turns out that only latter approach is secure.

## Key Derivation

The key we generate from the Diffie-Hellman key exchange may not be sufficient for AES or HMAC. For example, it may not be long enough, it may be of the wrong size, or may have a distribution that doesn't preserve the security guarantees of AES. Moreover, we want to use different keys for AES and HMAC to preserve security. To this end, we use a **secure key derivation function** to convert a shared secret into an acceptable key. In this assignment, we use **HKDF (HMAC-based Key Derivation Function)**, a widely used key derivation function, to generate secure keys. To ensure that HKDF generates different keys for AES and HMAC, we **salt** the Diffie-Hellman shared secret in the HKDF calls. Salts have been provided for you already in the stencil code, and should be passed into the HKDF call as a parameter. We will use HKDF two times in this assignment, once to generate a key for AES and once to generate a key for HMAC.

## Diffie-Hellman Ratchet

An undesirable property of using a single key throughout the whole session is that if the key is leaked or cracked at any point, an adversary could read all messages in the entire session. How can we remedy this? A solution can be found in the **Double Ratchet Algorithm** developed by the titular **Signal** company. Criticially, they implement what is known as a **[Diffie-Hellman Ratchet](https://signal.org/docs/specifications/doubleratchet/#diffie-hellman-ratchet)** which has parties constantly switching their shared secret. Then, even if you break in at time $T$, the keys will eventually be switched, limiting the number of messages the adversary can read before needing to break in again. Please read the Diffie-Hellman Ratchet section of the spec, linked above.

In short, this is how the ratchet works. Each time the direction of communication changes (*i.e.* Alice starts sending messages after the last thing she did was receive a message), the sender will generate a new Diffie-Hellman keypair and send their new public value. The sender will generate a new encryption key by combining their new private value with the receiver's old (*i.e.* last heard of) public value, and the receiver will generate a new decryption key by combining the sender's newly received public value with their old (*i.e.* last generated/current) private value. Both parties will use this shared key in AES and HMAC by first running it through HKDF, as before.

![Architecture DH](/static/img/handout/signal/architecture_double_ratchet.png)
